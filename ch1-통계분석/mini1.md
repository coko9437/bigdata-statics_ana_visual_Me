
---

### **Ch1-3 (미니예제) 코드 종합 설명**

이 코드는 `seaborn`에 내장된 **`tips` 데이터셋**을 사용하여 세 가지 핵심 데이터 분석 및 시각화 작업을 수행합니다. `tips` 데이터는 레스토랑 손님들이 지불한 총액, 팁, 성별, 요일, 시간 등의 정보를 담고 있습니다.

1.  **예제 1 (분포 비교):** `for` 반복문과 `histplot`을 사용하여 **요일(day)별로 팁(tip)의 분포**가 어떻게 다른지 하나의 그래프에 겹쳐 그려 비교합니다. 이를 통해 특정 요일에 팁을 더 많이 주는 경향이 있는지 시각적으로 탐색합니다.
2.  **예제 2 (상관 분석):** `tips` 데이터의 숫자형 변수(총 지불액, 팁, 인원수)들 간의 **상관관계를 계산**하고, 이를 **히트맵(Heatmap)**으로 시각화합니다. 변수들 사이에 얼마나 강한 선형 관계가 있는지 한눈에 파악하는 것이 목표입니다.
3.  **예제 3 (회귀 분석):** `statsmodels` 라이브러리를 사용해 `total_bill`(총 지불액)과 `size`(인원수)가 `tip`(팁)에 미치는 영향을 분석하는 **다중 선형 회귀 모델**을 만듭니다. 그리고 **부분 회귀 플롯(Partial Regression Plot)**을 이용해, 인원수의 영향을 제외했을 때 총 지불액이 팁에 미치는 순수한 영향력을 시각적으로 확인합니다.

---

### **예제 1: 요일별 팁(tip) 분포 비교하기**

#### **1. 코드, 문법 및 개별 설명**

```python
# %%
import seaborn as sns
import matplotlib.pyplot as plt
import matplotlib.font_manager as fm

# ... (한글 폰트 설정 부분 생략) ...

# 1. tips 데이터셋 불러오기
tips = sns.load_dataset("tips")

# 2. 그래프 스타일 설정
sns.set_style("darkgrid")

# 3. 요일별 분포도 그리기
# 'day' 컬럼의 고유한 값들(요일)을 추출 -> ['Thur', 'Fri', 'Sat', 'Sun']
days = tips["day"].unique()

# for 반복문을 통해 각 요일별로 그래프를 그림
for day in days:
    # 'tips' 데이터프레임에서 현재 요일(day)에 해당하는 데이터만 필터링
    subset = tips[tips["day"] == day]

    # 필터링된 데이터(subset)의 'tip' 컬럼을 사용하여 히스토그램과 KDE 곡선을 그림
    # label=day 옵션을 통해 각 그래프에 요일 이름을 범례로 지정
    sns.histplot(subset["tip"], kde=True, label=day)

# 그래프 제목 및 축 레이블 설정
plt.title("요일별 팁 분포")
plt.xlabel("Tip")
plt.ylabel("Density") # histplot에서는 빈도(Frequency)를 나타냄
plt.legend() # 각 그래프의 label을 표시하는 범례 추가
plt.show()

# 결과 해석:
# 그래프를 통해 토요일(Sat)과 일요일(Sun)에 팁의 분포가 오른쪽으로 더 길게 뻗어있는 것을 볼 수 있음.
# 이는 주말에 고액의 팁이 나올 확률이 평일보다 높다는 것을 시사.
# 전반적으로 2~4달러 사이의 팁이 가장 흔하게 나타남.
```

#### **2. 해당 설명**

이 예제는 **그룹별 데이터 분포를 비교**하는 가장 기본적인 방법을 보여줍니다. `for` 반복문을 사용하여 데이터를 그룹별로 순회하고, 각 그룹의 데이터를 동일한 축에 겹쳐 그리는 방식은 매우 흔하게 사용됩니다. `seaborn`의 `histplot` (또는 구버전의 `distplot`)은 데이터의 분포, 즉 어떤 값들이 얼마나 자주 나타나는지를 시각적으로 보여주는 데 탁월합니다. `kde=True` 옵션은 히스토그램의 막대를 부드러운 곡선으로 표현한 **커널 밀도 추정(Kernel Density Estimate)** 그래프를 함께 그려주어, 데이터 분포의 전반적인 형태를 파악하기 용이하게 합니다.

#### **3. 응용 가능한 예제**

**"고객 등급별 월 평균 구매액 분포 비교"**

온라인 쇼핑몰의 고객 데이터를 'VIP', 'Gold', 'Silver' 등급으로 나눈 뒤, `for` 문을 사용해 각 등급별 '월 평균 구매액'의 분포를 `histplot`으로 겹쳐 그릴 수 있습니다. 이를 통해 "VIP 고객들은 실제로 다른 등급의 고객들보다 월등히 높은 금액을 사용하는가?"를 시각적으로 확인할 수 있습니다.

#### **4. 추가하고 싶은 내용 (FacetGrid 활용)**

여러 그룹의 분포를 하나의 축에 겹쳐 그리면 그래프가 복잡해질 수 있습니다. 이럴 때 `seaborn`의 `FacetGrid`나 `displot` (kind='hist')을 사용하면 각 그룹별로 그래프를 분리하여 나란히 배열할 수 있어 비교가 더 용이합니다.

```python
# FacetGrid를 사용한 더 깔끔한 시각화
sns.displot(data=tips, x="tip", col="day", kde=True)
plt.show()
```

#### **5. 심화 내용 (통계적 검증: ANOVA)**

그래프를 통해 주말과 평일의 팁 분포가 달라 보이는 것을 확인했습니다. 만약 "요일 그룹 간 팁의 평균에 통계적으로 유의미한 차이가 있는가?"를 수치적으로 검증하고 싶다면, 세 개 이상의 그룹 평균을 비교하는 **분산 분석(ANOVA, Analysis of Variance)**을 사용할 수 있습니다. 이는 t-검정을 여러 그룹으로 확장한 개념입니다.

---

### **예제 2: 숫자형 변수 간 상관관계 히트맵 그리기**

#### **1. 코드, 문법 및 개별 설명**

```python
# %%
# ... (라이브러리 및 폰트 설정 생략) ...

# 1. tips 데이터셋 불러오기
tips = sns.load_dataset("tips")

# 2. 숫자형 변수만 선택하여 새로운 데이터프레임 생성
num_cols = ["total_bill", "tip", "size"]
heatmap_data = tips[num_cols]

# 3. 상관계수 행렬 계산
# .corr() 함수가 데이터프레임의 숫자형 컬럼들 간의 피어슨 상관계수를 계산
corr_matrix = heatmap_data.corr()
# 결과 (corr_matrix):
#               total_bill       tip      size
# total_bill      1.000000  0.675734  0.598315
# tip             0.675734  1.000000  0.489299
# size            0.598315  0.489299  1.000000

# 4. 히트맵 시각화
plt.figure(figsize=(5, 4))
# 연산 과정:
# 1. corr_matrix 데이터를 기반으로 히트맵의 구조를 만듦
# 2. annot=True: 각 셀에 상관계수 값을 텍스트로 표시
# 3. cmap="coolwarm": 색상 맵을 파란색(-1)~흰색(0)~빨간색(1)으로 설정
# 4. vmin=-1, vmax=1: 색상 막대의 최소/최대값을 -1과 1로 고정하여 일관된 색상 표현
sns.heatmap(corr_matrix, annot=True, cmap="coolwarm", vmin=-1, vmax=1)
plt.title("숫자형 변수 간 상관관계")
plt.show()

# 결과 해석:
# total_bill과 tip의 상관계수가 0.68로 강한 양의 상관관계를 보임. -> "총 지불액이 클수록 팁도 많이 주는 경향이 있다."
# size와 tip도 0.49로 어느 정도 양의 상관관계를 보임. -> "식사 인원이 많을수록 팁도 많아지는 경향이 있다."
```

#### **2. 해당 설명**

이 예제는 타이타닉 분석에서 다룬 **상관 분석**과 **히트맵 시각화**를 그대로 복습합니다. 데이터 분석 프로젝트에서 변수들 간의 관계를 파악하는 것은 가장 기본적인 탐색 과정 중 하나입니다. `pandas`의 `.corr()` 메서드로 상관계수 행렬을 계산하고, 이를 `seaborn`의 `heatmap()`으로 시각화하는 것은 거의 공식처럼 사용되는 조합입니다. `annot=True` 옵션은 히트맵에 실제 숫자 값을 표시해주어 색상만으로 파악하기 어려운 미세한 차이를 정확히 알 수 있게 해주는 중요한 파라미터입니다.

#### **3. 응용 가능한 예제**

**"주식 시장 데이터 분석"**

여러 기술주(예: 삼성전자, Apple, Google)의 일일 수익률 데이터를 사용하여 상관계수 행렬을 계산하고 히트맵으로 시각화할 수 있습니다. 이를 통해 "Apple의 주가가 오를 때 Google의 주가도 함께 오르는 경향이 있는가?"와 같은 주식 간의 연동성(커플링)을 파악하여 포트폴리오 분산 투자 전략을 세우는 데 활용할 수 있습니다.

#### **4. 추가하고 싶은 내용 (상관계수 종류)**

`.corr()` 메서드는 기본적으로 **피어슨(Pearson) 상관계수**를 계산합니다. 이는 두 변수 간의 **선형적인** 관계를 측정합니다. 만약 변수들이 선형 관계는 아니지만 순위 관계(한쪽이 증가할 때 다른 쪽도 단조롭게 증가/감소)를 가질 경우에는 **스피어만(Spearman) 상관계수**(`method='spearman'`)를 사용하는 것이 더 적절할 수 있습니다.

#### **5. 심화 내용 (인과관계의 함정)**

히트맵 결과, `total_bill`과 `size`도 0.60의 강한 상관관계를 보입니다. 이는 당연합니다(인원이 많으면 총액이 커짐). 여기서 `total_bill`과 `tip`의 관계, 그리고 `size`와 `tip`의 관계를 볼 때, '`total_bill`이 `size`의 영향을 받는다'는 점을 인지해야 합니다. 즉, '인원이 많아지면 -> 총액이 커지고 -> 팁이 많아진다'는 연쇄적인 관계일 수 있습니다. 다음 예제 3의 부분 회귀 플롯은 바로 이러한 혼란을 해결하는 데 도움을 줍니다.

---

### **예제 3: 회귀 모델 적합 및 부분 회귀 플롯 확인**

#### **1. 코드, 문법 및 개별 설명**

```python
# %%
import statsmodels.api as sm
from statsmodels.graphics.regressionplots import plot_partregress

# ... (데이터 로드 생략) ...

# 2. 독립 변수(X)와 종속 변수(y) 설정
X = tips[["total_bill", "size"]] # 원인(설명 변수)
y = tips["tip"] # 결과(목표 변수)

# 3. 상수항(절편) 추가
# statsmodels는 회귀식의 절편(y = b0 + b1*x1 + ...)을 자동으로 추가하지 않으므로,
# 수동으로 상수(모든 값이 1인 열)를 추가해 주어야 함.
X = sm.add_constant(X)

# 4. OLS(최소자승법) 회귀 모델 학습
# y ~ X 관계를 설명하는 최적의 계수(coefficient)들을 찾음
model = sm.OLS(y, X).fit()

# 5. 부분 회귀 플롯 시각화
fig, ax = plt.subplots(figsize=(6, 4))
# 'tip'과 'total_bill'의 관계를 그리되, 'size'의 영향을 제거한 후의 순수한 관계를 보여줌
# 연산 과정:
# 1. tip을 size로 회귀시킨 후의 잔차(y_resid)를 구함 (size로 설명되지 않는 tip의 변동)
# 2. total_bill을 size로 회귀시킨 후의 잔차(x_resid)를 구함 (size로 설명되지 않는 total_bill의 변동)
# 3. 위에서 구한 두 잔차(y_resid, x_resid)를 가지고 산점도를 그림
plot_partregress("tip", "total_bill", ["size"], data=tips, ax=ax)
plt.title("Partial Regression Plot for total_bill")
plt.show()

# 결과 해석:
# 그래프의 점들이 뚜렷한 우상향 추세를 보임.
# 이는 'size'(인원수)의 영향을 제거하더라도, 여전히 'total_bill'(총 지불액)이 클수록
# 'tip'이 증가하는 강한 양의 선형 관계가 존재함을 의미.
# 즉, total_bill은 tip에 독립적으로도 중요한 영향을 미치는 변수임을 시각적으로 확인.
```

#### **2. 해당 설명**

이 예제는 와인 분석에서 사용했던 **다중 회귀 분석**과 **부분 회귀 플롯**을 복습합니다. 다중 회귀 분석에서는 여러 독립 변수가 동시에 종속 변수에 영향을 미칩니다. 이때 "다른 변수들의 영향을 모두 고정(통제)했을 때, 특정 한 변수가 미치는 순수한 영향력은 어느 정도일까?"를 확인하는 것이 중요합니다. **부분 회귀 플롯(Partial Regression Plot)**이 바로 이 질문에 대한 시각적인 답을 제공합니다. 이 플롯을 통해 우리는 `total_bill`이 단순히 `size` 때문에 `tip`과 관련이 있는 것이 아니라, 그 자체로도 `tip`을 예측하는 데 중요한 독립적인 변수임을 확인할 수 있습니다.

#### **3. 응용 가능한 예제**

**"아파트 가격 예측 모델 분석"**

'평수', '한강 조망 여부', '역세권 여부'를 독립 변수로 하여 '매매가'를 예측하는 회귀 모델을 만들었다고 가정합시다. 이때 부분 회귀 플롯으로 '평수'의 영향을 시각화하면, '한강 조망'과 '역세권'이라는 요소를 모두 통제했을 때 순수하게 평수가 1평 늘어날 때마다 매매가가 어느 정도 상승하는 경향이 있는지 직관적으로 파악할 수 있습니다.

#### **4. 추가하고 싶은 내용 (모델 요약 정보 확인)**

`model.summary()` 코드를 추가하여 학습된 회귀 모델의 상세한 통계 정보를 확인하는 것이 매우 중요합니다.

```python
print(model.summary())
```

이 요약표를 통해 각 변수(`total_bill`, `size`)의 계수(coefficient), 통계적 유의성(P>|t|), 그리고 모델의 전체 설명력(R-squared) 등을 수치적으로 정확하게 파악할 수 있으며, 이는 시각적인 해석을 뒷받침하는 강력한 근거가 됩니다.

#### **5. 심화 내용 (VIF를 이용한 다중공선성 확인)**

예제 2에서 언급된 다중공선성 문제를 수치적으로 진단하는 방법으로 **VIF(분산 팽창 계수, Variance Inflation Factor)**가 있습니다. VIF는 특정 독립 변수가 다른 독립 변수들에 의해 얼마나 설명되는지를 나타내는 지표로, 보통 VIF 값이 10을 초과하면 다중공선성 문제가 심각하다고 판단합니다. `statsmodels` 라이브러리에서 VIF를 계산하는 함수를 제공하므로, 회귀 분석 시 모델의 안정성을 확인하는 데 유용하게 사용할 수 있습니다.