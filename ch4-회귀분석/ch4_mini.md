
---

### **1. 와인 품질 예측 (Wine Quality Prediction) - 전형적인 회귀 문제**

이 코드는 레드 와인의 화학적 성분(알코올 도수, 산도 등)을 바탕으로 와인의 `quality`(품질 점수)를 예측하는, 회귀 분석의 교과서적인 예제입니다.

#### **Ch-Wine 코드 종합 설명**

이 코드는 **선형 회귀 모델**을 사용하여 와인의 여러 화학적 특성(독립 변수)들이 품질 점수(종속 변수)에 어떤 영향을 미치는지 분석하고, 이를 통해 미지의 와인 품질을 예측하는 모델을 구축합니다.

1.  **데이터 준비 및 특성 선택:** `winequality-red2.csv` 데이터를 불러온 후, `drop` 함수를 이용해 분석에 사용할 주요 특성 6가지만 남깁니다. 이는 모델을 단순화하고 해석을 용이하게 하기 위한 **특성 선택** 과정입니다.
2.  **모델 학습 및 평가:** 데이터를 학습용과 테스트용으로 분할하고, `LinearRegression` 모델을 학습시킵니다. 학습된 모델의 성능은 `MSE`와 `R²` 지표로 평가됩니다.
3.  **결과 해석 및 시각화:** 학습된 **회귀 계수**를 통해 알코올 도수, 산도 등 어떤 요인이 품질 점수에 긍정적 또는 부정적 영향을 주는지 정량적으로 분석합니다. `regplot`을 통해 각 화학 성분과 품질 점수 간의 선형 관계를 시각적으로 확인하며 마무리합니다.

---

#### **Part 1: 모델 학습 및 평가**

##### **1. 코드, 문법 및 개별 설명**

```python
# %%
import pandas as pd
from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error, r2_score

# 와인 데이터 로드
data_df = pd.read_csv('./winequality-red2.csv', header=0, engine='python')

# 분석에 사용하지 않을 컬럼 5개 제거 (특성 선택)
data_df = data_df.drop(["chlorides", "free sulfur dioxide", "total sulfur dioxide", "pH", "sulphates"], axis=1, inplace=False)

# %%
# X(독립 변수)와 Y(종속 변수) 분리
Y = data_df["quality"] # 예측 목표: 와인 품질 점수
X = data_df.drop(["quality"], axis=1, inplace=False)

# 데이터 분할 (훈련 70%, 테스트 30%)
X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.3, random_state=0)

# %%
# 모델 생성, 학습, 예측
lr = LinearRegression()
lr.fit(X_train, Y_train)
y_predict = lr.predict(X_test)

# %%
# 성능 평가
mse = mean_squared_error(Y_test, y_predict)
rmse = np.sqrt(mse)
r2_value = r2_score(Y_test, y_predict)

print(f"mse : {mse}, rmse : {rmse}, r2_value : {r2_value}")
# 결과 해석 예시:
# rmse: 약 0.62 -> 모델의 품질 예측이 실제 점수와 평균적으로 약 0.62점 차이 남.
# r2_value: 약 0.35 -> 모델이 와인 품질 변화의 약 35%밖에 설명하지 못함. (성능이 썩 좋지는 않음)
```

##### **2. 해당 설명**

이 코드의 분석 결과에서 가장 주목해야 할 부분은 **`r2_value` (R² 값)가 약 0.35로 상대적으로 낮게 나왔다는 점**입니다. 이는 무엇을 의미할까요? "우리가 선택한 6개의 화학 성분과 와인 품질 사이에는 단순한 '직선' 관계만으로는 설명하기 어려운, 더 복잡한 무언가가 있다"는 뜻입니다. 즉, 선형 회귀 모델이 와인 품질의 변동성을 단 35%만 설명할 수 있다는 의미로, 모델의 예측 성능이 그리 높지 않음을 시사합니다.

이처럼 **낮은 R² 값**은 모델이 잘못되었다기보다는, **"선형 회귀라는 단순한 모델의 한계"** 또는 **"더 중요한 다른 특성이 누락되었을 가능성"**을 알려주는 중요한 분석 결과입니다.

---

#### **Part 2: 모델 해석 및 시각화**

##### **1. 코드, 문법 및 개별 설명**

```python
# %%
# 회귀 계수 확인 및 정렬
coef = pd.Series(data=np.round(lr.coef_, 2), index=X.columns)
print(coef.sort_values(ascending=False))
# 결과 해석:
# alcohol             0.30  -> 알코올 도수가 1 증가하면 품질 점수가 0.30 오르는 경향
# fixed acidity       0.03
# residual sugar      0.01
# citric acid        -0.08
# density            -4.32
# volatile acidity   -1.20  -> 휘발성 산도가 1 증가하면 품질 점수가 1.20 감소하는 경향

# %%
# 시각화
# ... (regplot 코드 생략) ...
```

##### **2. 해당 설명**

회귀 계수는 모델의 성능(R²)과 별개로, 각 변수가 품질에 미치는 **영향의 방향성과 강도**에 대한 유용한 통찰을 줍니다.
*   **`alcohol`(알코올 도수)**: 계수가 가장 큰 양수(0.30)입니다. 이는 모델이 **"알코올 도수가 높을수록 품질이 좋다"**는 가장 강력한 규칙을 학습했음을 의미합니다.
*   **`volatile acidity`(휘발성 산도)**: 계수가 음수(-1.20)입니다. 이는 **"와인에 식초 같은 신 냄새를 유발하는 휘발성 산도가 높을수록 품질이 나쁘다"**는 규칙을 학습했음을 보여줍니다.

`regplot` 시각화는 이러한 관계를 명확히 보여줍니다. `alcohol` 그래프는 뚜렷한 우상향 패턴을, `volatile acidity`는 우하향 패턴을 보일 것입니다.

##### **3. 심화 내용 (더 나은 모델은 없을까?)**

낮은 R² 값을 개선하려면 어떻게 해야 할까요?
1.  **더 복잡한 모델 사용**: 와인 품질은 여러 성분의 복합적인 상호작용으로 결정될 수 있습니다. 이런 비선형(non-linear) 관계를 잘 학습하는 **`RandomForestRegressor`**나 **`GradientBoostingRegressor`** 같은 고급 모델을 사용하면 R² 점수를 크게 향상시킬 수 있습니다.
2.  **문제 재정의 (회귀 -> 분류)**: `quality` 점수는 3, 4, 5, 6, 7, 8처럼 정해진 값만 가집니다. 이를 예측하는 것은 사실 회귀보다 **분류(Classification)** 문제에 더 가깝습니다. 예를 들어, 품질 점수 6 이상을 '좋은 와인(1)', 6 미만을 '나쁜 와인(0)'으로 변환하여 "이 와인이 좋은 와인일까, 아닐까?"를 맞추는 분류 문제로 바꾸면, 더 명확하고 성능 좋은 모델을 만들 수 있습니다.

---

### **2. 타이타닉 생존자 예측 - 회귀를 사용하면 안 되는 분류 문제**

이 코드는 타이타닉호 탑승객의 정보(성별, 나이, 객실 등급 등)를 이용해 생존 여부(`survived`)를 예측합니다. 이 예제는 **"왜 회귀 분석을 여기에 쓰면 안 되는지"**를 배울 수 있는 매우 중요한 사례입니다.

#### **Ch-Titanic 코드 종합 설명**

이 코드는 **선형 회귀 모델**을 타이타닉 생존자 예측이라는 **분류(Classification)** 문제에 잘못 적용한 사례를 보여줍니다. 분석의 목표는 생존(1) 또는 사망(0)이라는 두 가지 범주 중 하나를 예측하는 것입니다.

1.  **데이터 준비:** 이전 실습에서 전처리된 `titanic_new_family.csv` 데이터를 사용하며, 분석에 필요한 숫자형 특성들만 남깁니다.
2.  **잘못된 모델 적용:** 생존 여부(`survived`)를 예측하기 위해 선형 회귀 모델을 학습시킵니다.
3.  **성능 평가의 함정:** 회귀 평가지표인 `MSE`와 `R²`로 모델을 평가합니다. R² 값이 약 0.38로 계산되지만, 이는 분류 문제에서는 큰 의미를 갖지 못하는 수치입니다.
4.  **해석의 어려움:** `regplot`을 통해 시각화를 시도하지만, y축의 값이 0과 1에만 몰려있어 회귀선이 데이터를 제대로 표현하지 못하는 것을 확인할 수 있습니다.

---

#### **핵심: 왜 선형 회귀를 쓰면 안 될까요? (가장 중요한 학습 포인트)**

우리가 예측하려는 `survived`는 0(사망) 또는 1(생존)이라는 **두 가지 선택지**만 있는 **범주형(categorical)** 데이터입니다. 이런 문제를 **분류(Classification)** 문제라고 합니다.

선형 회귀는 와인 품질처럼 **연속적인 숫자 값**을 예측하도록 설계되었습니다. 이를 분류 문제에 억지로 적용하면 다음과 같은 심각한 문제가 발생합니다.

1.  **예측값이 0과 1을 벗어납니다**: 선형 회귀는 직선을 긋는 모델이므로, 예측값이 1보다 큰 1.5가 나오거나 0보다 작은 -0.2가 나올 수 있습니다. "생존 확률이 150%"나 "-20%"라는 것은 말이 되지 않습니다.
2.  **관계 해석이 왜곡됩니다**: `regplot` 시각화에서 볼 수 있듯이, 모든 데이터가 y=0과 y=1 라인에 붙어있는데, 이 점들을 가장 잘 표현하는 하나의 '직선'을 긋는 것은 데이터의 본질적인 패턴을 왜곡합니다.

> **결론: 타이타닉 생존 예측과 같이 '예/아니오', 'A/B/C' 등 정해진 카테고리를 예측하는 문제에는 회귀가 아닌 '분류' 모델을 사용해야 합니다.**

#### **그렇다면 어떤 모델을 써야 할까요? (올바른 접근법)**

이런 분류 문제에는 **로지스틱 회귀(Logistic Regression)**라는 모델을 사용해야 합니다.

*   **로지스틱 회귀란?**: 이름에 '회귀'가 들어가 헷갈릴 수 있지만, **분류를 위한 대표적인 모델**입니다. 선형 회귀와 원리는 비슷하지만, 마지막에 **시그모이드(Sigmoid) 함수**라는 장치를 추가하여 어떤 경우에도 예측 결과가 **0과 1 사이의 확률값**으로 나오도록 만들어 줍니다. 예를 들어, 예측값이 0.8이라면 "80% 확률로 생존"이라고 해석할 수 있습니다.

#### **올바른 평가 지표**

분류 문제는 MSE나 R²로 평가하지 않습니다. 대신 다음과 같은 지표를 사용합니다.

*   **정확도(Accuracy)**: 전체 예측 중 정답을 맞춘 비율 (가장 직관적임)
*   **정밀도(Precision)**, **재현율(Recall)**, **F1-점수(F1-Score)**: 모델이 얼마나 실수 없이 예측하는지 더 상세하게 평가하는 지표들

이번 두 코드를 통해 회귀 분석의 적용법과 그 한계, 그리고 문제의 성격에 따라 올바른 모델(회귀 vs 분류)을 선택하는 것이 얼마나 중요한지 배우셨기를 바랍니다. 아주 좋은 학습 경험이 되셨을 겁니다